#!/command/with-contenv bash
# shellcheck shell=bash

set -Eeuo pipefail

# --- config from env
IMPORT_SOURCES="${IMPORT_SOURCES:-}"
STAGING_ROOT="${STAGING_ROOT:-/data/Audio/Staging}"
STAGING_PREFIX="${STAGING_PREFIX:-Beets}"
BEETS_CMD="${BEETS_CMD:-/opt/beets/bin/beet}"
BEETS_IMPORT_ARGS="${BEETS_IMPORT_ARGS:-}"
DRY_RUN="${DRY_RUN:-0}"
LOG_DIR="${LOG_DIR:-/logs}"
RUN_ID="$(date +'%Y%m%d-%H%M%S')"
RUN_DIR="$LOG_DIR/run-$RUN_ID"
MARKER_NAME="${MARKER_NAME:-.beets-staging.marker}"
MARKER_SIG="${MARKER_SIG:-beets-importer-managed-v1}"

FPCALC=/usr/bin/fpcalc
export FPCALC

log() {
  local ts msg
  ts="$(date +'%F %T %Z')"
  msg="[$ts] $(printf '%s ' "$@")"
  msg="${msg% }"

  if [[ -n "${RUN_DIR:-}" ]]; then
    mkdir -p -- "$RUN_DIR" 2>/dev/null || true
    printf '%s\n' "$msg" | tee -a "$RUN_DIR/importer.log" >&2
  else
    # Fallback: no RUN_DIR yet – just stderr
    printf '%s\n' "$msg" >&2
  fi
}
die() { log "ERROR: $*"; exit 1; }

[[ -n "${IMPORT_SOURCES// }" ]] || die "IMPORT_SOURCES is required (comma or newline separated)."

# normalize sources into an array (split on comma or newline)
IFS=$'\n' read -r -d '' -a SOURCES < <(
  printf '%s' "$IMPORT_SOURCES" | tr ',' '\n' | sed '/^\s*$/d' && printf '\0'
)

run() {
  if [[ "$DRY_RUN" == "1" ]]; then
    log "DRY-RUN: $*"
  else
    eval "$@"
  fi
}

# ensure tools exist
need_cmds=(rsync cuebreakpoints shnsplit cuetag flac)
for c in "${need_cmds[@]}"; do
  command -v "$c" >/dev/null 2>&1 || die "Missing dependency: $c"
done
command -v "$BEETS_CMD" >/dev/null 2>&1 || die "beets CLI not found: $BEETS_CMD"

# make staging root
[[ -d "$STAGING_ROOT" ]] || run "mkdir -p -- \"$STAGING_ROOT\""

staging_dirs=()

same_fs() {
  # compare device numbers; identical => same filesystem
  [[ "$(stat -c %d "$1")" == "$(stat -c %d "$2")" ]]
}

hardlink_mirror() {
  local src="$1" dst="$2"
  [[ -d "$src" ]] || { log "Skip (not a dir): $src"; return 0; }

  local dst_parent
  dst_parent="$(dirname "$dst")"

  if ! same_fs "$src" "$dst_parent"; then
    die "Cannot hardlink: '$src' and '$dst_parent' are on different filesystems.
Set STAGING_ROOT under the same mount as src (e.g. /data/...), or export COPY_MIRROR=1 to allow full copies."
  fi

  log "Creating hard-linked snapshot: src='$src' -> dst='$dst'"
  run "mkdir -p -- \"$dst\""
  local tmp=\"${dst}.tmp.$RANDOM\"
  run "mkdir -p -- $tmp"
  run "printf '%s\n' \"$MARKER_SIG\" > \"$tmp/$MARKER_NAME\""


  local linkopt="--link-dest=\"$src\""
  [[ "${COPY_MIRROR:-0}" == "1" ]] && linkopt=""

  # trailing slashes matter
  run "rsync -aH --delete --info=stats1 $linkopt \"$src/\" \"$tmp/\" 2> >(tee -a \"$RUN_DIR/rsync-$(basename "$dst").log\" >&2)"
  run "rm -rf -- \"$dst\""
  run "mv -- \"$tmp\" \"$dst\""
  run "printf '%s\n' \"$MARKER_SIG\" > \"$dst/$MARKER_NAME\""
}

# Parse FILE target from a .cue; supports quoted/spacey names
cue_target_audio() {
  # prints the referenced audio filename relative to cue dir
  awk -F '\"' '/^[Ff][Ii][Ll][Ee][[:space:]]+\"/ {print $2; exit}' "$1"
}

split_cue_flac_dir() {
  local dir="$1"
  # find all .cue files in this directory (non-recursive: we already walk recursively elsewhere)
  shopt -s nullglob
  local cues=("$dir"/*.cue "$dir"/*.CUE)
  shopt -u nullglob
  ((${#cues[@]})) || return 0

  for cue in "${cues[@]}"; do
    local rel_audio
    rel_audio="$(cue_target_audio "$cue" || true)"
    if [[ -z "$rel_audio" ]]; then
      log "WARN: $cue has no FILE line; skipping."
      continue
    fi
    local audio="$dir/$rel_audio"
    if [[ ! -f "$audio" ]]; then
      log "WARN: Referenced audio not found for $cue -> '$rel_audio' ; skipping."
      continue
    fi

    # We only handle single-file image cues cleanly
    # If cue references multiple FILE lines, cuebreakpoints still works, but tagging may be odd.
    local bp_count
    bp_count=$(cuebreakpoints "$cue" | wc -l | tr -d ' ')
    if [[ "$bp_count" -eq 0 ]]; then
      log "WARN: No breakpoints in $cue; skipping."
      continue
    fi

    local splitdir="$dir/.split.$$"
    run "mkdir -p -- \"$splitdir\""

    log "Splitting: $(basename "$audio") using $(basename "$cue") -> $splitdir"
    # Split into individual FLAC tracks
    # -o flac uses flac encoder; -d selects output dir
    run "cuebreakpoints \"$cue\" | shnsplit -o flac -d \"$splitdir\" \"$audio\""

    # Tag new tracks from the cue sheet
    # cuetag expects a glob of the new files
    run "cuetag \"$cue\" \"$splitdir\"/split-track*.flac"

    # Move split tracks back to album dir
    run "find \"$splitdir\" -maxdepth 1 -type f -name 'split-track*.flac' -print0 | xargs -0 -I{} mv -n -- \"{}\" \"$dir\""

    # Clean up image pair (in STAGING ONLY)
    log "Removing original image pair from staging: $audio and $cue"
    run "rm -f -- \"$audio\" \"$cue\""
    run "rm -rf -- \"$splitdir\""
  done
}

# Walk a staging subtree and split any cue+flac image albums
split_all_cues_in_tree() {
  local root="$1"
  log "Scanning for .cue albums under: $root"
  # For each directory that contains a .cue, process it
  # Using -print0 and while read -d '' for safety
  find "$root" -type f \( -iname '*.cue' \) -print0 \
  | while IFS= read -r -d '' cuefile; do
      split_cue_flac_dir "$(dirname "$cuefile")"
    done
}

clean_staging_root() {
  # Must be set and absolute
  [[ -n "${STAGING_ROOT:-}" ]] || die "STAGING_ROOT is not set"
  [[ "$STAGING_ROOT" = /* ]] || die "STAGING_ROOT must be an absolute path: $STAGING_ROOT"

  # Resolve & basic safety checks
  local rs
  rs="$(readlink -f -- "$STAGING_ROOT" 2>/dev/null || realpath -- "$STAGING_ROOT")" \
    || die "Cannot resolve STAGING_ROOT: $STAGING_ROOT"
  [[ -d "$rs" ]] || { log "Staging root not found: $rs"; return 0; }
  case "$rs" in
    /|/bin|/boot|/dev|/etc|/home|/lib*|/proc|/root|/run|/sbin|/sys|/usr|/var)
      die "Refusing to clean suspicious STAGING_ROOT: $rs"
      ;;
  esac

  # Remove ONLY top-level dirs that carry our marker + signature
  find "$rs" -mindepth 1 -maxdepth 1 -type d -print0 \
  | while IFS= read -r -d '' d; do
      if [[ -f "$d/$MARKER_NAME" ]] && grep -qF "$MARKER_SIG" "$d/$MARKER_NAME"; then
        run "rm -rf -- \"$d\""
      else
        log "Skipping non-managed dir: $d"
      fi
    done
}

# --- main
for src in "${SOURCES[@]}"; do
  src="$(echo "$src" | sed 's/[[:space:]]\+$//;s/^[[:space:]]\+//')"
  [[ -n "$src" ]] || continue
  base="$(basename "$src")"
  dst="$STAGING_ROOT/${STAGING_PREFIX}_${base}"
  hardlink_mirror "$src" "$dst"
  staging_dirs+=("$dst")
done

# Process cue/flac image albums inside each staging dir
for d in "${staging_dirs[@]}"; do
  split_all_cues_in_tree "$d"
done

# Run beets import on the staging dirs
log "Running beets import on: ${staging_dirs[*]}"
if [[ "$DRY_RUN" == "1" ]]; then
  log "DRY-RUN: \"$BEETS_CMD\" import -l \"$RUN_DIR/beets-import.log\" $BEETS_IMPORT_ARGS \"${staging_dirs[*]}\""
else
  # You can add -m here if you want move semantics regardless of config:
  # e.g., BEETS_IMPORT_ARGS="${BEETS_IMPORT_ARGS} -m"
  set +e
  "$BEETS_CMD" import -l "$RUN_DIR/beets-import.log" "$BEETS_IMPORT_ARGS" "${staging_dirs[@]}" |& tee -a "$RUN_DIR/beets-stdout.log"
  rc=$?
  set -e
fi

if [[ $rc -ne 0 ]]; then
  # Make a per-run bundle and copy to STAGING_ROOT
  bundle="$LOG_DIR/error-bundle-$RUN_ID.tgz"
  run "tar -czf \"$bundle\" -C \"$RUN_DIR\" ."
  run "mkdir -p -- \"$STAGING_ROOT\""
  dest="$STAGING_ROOT/.beets-error-bundle-$RUN_ID.tgz"
  run "cp -a -- \"$bundle\" \"$dest\""
  run "ln -sfn \"$(basename "$dest")\" \"$STAGING_ROOT/.beets-error-bundle-latest.tgz\""
  log "Import failed (rc=$rc). Error bundle copied to: $dest"

  # Clean the staging root (removes only our marker-tagged dirs)
  clean_staging_root
  log "Staging root cleaned (kept error bundle)."
  exit "$rc"
fi

# Success: stateless—wipe our Beets_* and temp dirs under STAGING_ROOT
clean_staging_root
log "Import succeeded. Staging root cleaned."
exit 0
